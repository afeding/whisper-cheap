"""
Native Windows overlay bar (no Qt/Tk).

Creates a thin, always-on-top, borderless window positioned at the bottom (or top)
of the Windows work area (above the taskbar). Shows a status text and an RMS level bar.

Runs a dedicated Win32 message loop in a background thread and processes state updates
via a thread-safe queue polled by a timer.
"""

from __future__ import annotations

import queue
import threading
import time
from dataclasses import dataclass
from typing import Optional
import traceback

try:
    import win32api  # type: ignore
    import win32con  # type: ignore
    import win32gui  # type: ignore
except Exception:  # pragma: no cover - optional on non-Windows
    win32api = None
    win32con = None
    win32gui = None


@dataclass
class _Update:
    kind: str
    text: Optional[str] = None
    level: Optional[float] = None
    visible: Optional[bool] = None


class WinOverlayBar:
    def __init__(self, position: str = "bottom", opacity: float = 0.9) -> None:
        if win32gui is None or win32con is None or win32api is None:
            raise RuntimeError("pywin32 no disponible para overlay nativo")
        self.position = position if position in ("top", "bottom") else "bottom"
        self.opacity = float(opacity)
        self._q: "queue.SimpleQueue[_Update]" = queue.SimpleQueue()
        self._thread: Optional[threading.Thread] = None
        self._hwnd: Optional[int] = None
        self._running = threading.Event()
        self._ready = threading.Event()
        self._last_error: Optional[str] = None

        self._text = "Grabando..."
        self._level = 0.0
        self._visible = False

    def start(self) -> None:
        if self._thread and self._thread.is_alive():
            print("[win_overlay] Thread ya está corriendo")
            return
        print("[win_overlay] Iniciando thread...")
        self._running.set()
        self._thread = threading.Thread(target=self._run, daemon=True)
        self._thread.start()
        print("[win_overlay] Esperando a que la ventana esté lista...")
        self._ready.wait(timeout=1.5)
        if not self._ready.is_set():
            err = self._last_error or "No se pudo inicializar overlay (timeout)"
            print(f"[win_overlay] ERROR: {err}")
            raise RuntimeError(err)
        print("[win_overlay] Ventana lista")

    def stop(self) -> None:
        if not self._thread:
            return
        self._q.put(_Update(kind="quit"))
        self._running.clear()
        if self._thread.is_alive():
            self._thread.join(timeout=1.5)

    def show(self, text: str) -> None:
        print(f"[win_overlay] show() llamado con texto: '{text}'")
        self.start()
        print(f"[win_overlay] Encolando update: show, visible=True")
        self._q.put(_Update(kind="show", text=text, visible=True))

    def hide(self) -> None:
        if not self._ready.is_set():
            return
        self._q.put(_Update(kind="hide", visible=False))

    def set_text(self, text: str) -> None:
        self.start()
        self._q.put(_Update(kind="text", text=text))

    def set_level(self, rms: float) -> None:
        if not self._ready.is_set():
            return
        self._q.put(_Update(kind="level", level=float(rms)))

    # ---- Win32 internals ----
    def _run(self) -> None:
        assert win32gui is not None and win32con is not None and win32api is not None

        try:
            print("[win_overlay] _run() iniciado")
            class_name = f"WhisperCheapOverlayBar_{int(time.time() * 1000)}"

            left, top, width, height = self._initial_rect()
            print(f"[win_overlay] Coordenadas: left={left}, top={top}, width={width}, height={height}")

            def wndproc(hwnd, msg, wparam, lparam):  # noqa: ANN001
                if msg == win32con.WM_CREATE:
                    # Poll update queue at 20Hz
                    win32gui.SetTimer(hwnd, 1, 50, 0)
                    return 0

                if msg == win32con.WM_TIMER:
                    self._drain_updates()
                    return 0

                if msg == win32con.WM_PAINT:
                    self._on_paint(hwnd)
                    return 0

                if msg == win32con.WM_DESTROY:
                    try:
                        win32gui.KillTimer(hwnd, 1)
                    except Exception:
                        pass
                    win32gui.PostQuitMessage(0)
                    return 0

                return win32gui.DefWindowProc(hwnd, msg, wparam, lparam)

            wc = win32gui.WNDCLASS()
            wc.hInstance = win32api.GetModuleHandle(None)
            wc.lpszClassName = class_name
            wc.lpfnWndProc = wndproc
            wc.hCursor = win32gui.LoadCursor(0, win32con.IDC_ARROW)
            win32gui.RegisterClass(wc)

            ex_style = win32con.WS_EX_TOPMOST | win32con.WS_EX_TOOLWINDOW | win32con.WS_EX_LAYERED
            style = win32con.WS_POPUP

            hwnd = win32gui.CreateWindowEx(
                ex_style,
                class_name,
                "WhisperCheapOverlay",
                style,
                left,
                top,
                width,
                height,
                0,
                0,
                wc.hInstance,
                None,
            )
            self._hwnd = hwnd
            print(f"[win_overlay] Ventana creada con hwnd={hwnd}")

            # Start hidden; show on demand.
            try:
                win32gui.ShowWindow(hwnd, win32con.SW_HIDE)
                win32gui.UpdateWindow(hwnd)
                print("[win_overlay] Ventana oculta inicialmente (SW_HIDE)")
            except Exception as e:
                print(f"[win_overlay] Error al ocultar ventana: {e}")

            # Apply global opacity
            try:
                alpha = max(40, min(int(self.opacity * 255), 255))
                win32gui.SetLayeredWindowAttributes(hwnd, 0, alpha, win32con.LWA_ALPHA)
                print(f"[win_overlay] Opacity aplicado: {self.opacity} (alpha={alpha})")
            except Exception as e:
                print(f"[win_overlay] Error al aplicar opacity: {e}")

            self._ready.set()
            print("[win_overlay] _ready señalado, iniciando message loop")

            try:
                win32gui.PumpMessages()
            except Exception:
                pass
            finally:
                self._running.clear()
                self._hwnd = None
        except Exception:
            self._last_error = traceback.format_exc()
            self._ready.set()
            self._running.clear()

    def _initial_rect(self):
        assert win32api is not None and win32gui is not None and win32con is not None
        # Prefer the monitor nearest the cursor (multi-monitor friendly).
        try:
            x, y = win32api.GetCursorPos()
            mon = win32api.MonitorFromPoint((x, y), win32con.MONITOR_DEFAULTTONEAREST)
            info = win32api.GetMonitorInfo(mon)
            # rcWork excludes taskbar for that monitor.
            left, top, right, bottom = info.get("Work") or info.get("Monitor")
        except Exception:
            # Fallback: system work area for primary monitor
            try:
                left, top, right, bottom = win32gui.SystemParametersInfo(win32con.SPI_GETWORKAREA)
            except Exception:
                # Last resort: full screen metrics (may overlap taskbar)
                left, top = 0, 0
                right = int(win32api.GetSystemMetrics(win32con.SM_CXSCREEN))
                bottom = int(win32api.GetSystemMetrics(win32con.SM_CYSCREEN))
        work_w = int(right - left)
        height = 48
        width = work_w
        x = int(left)
        y = int(top) if self.position == "top" else int(bottom - height)
        return x, y, width, height

    def _drain_updates(self) -> None:
        hwnd = self._hwnd
        if not hwnd:
            return
        dirty = False
        try:
            while True:
                upd = self._q.get_nowait()
                print(f"[win_overlay] _drain_updates: recibido update kind={upd.kind}, text={upd.text}, visible={upd.visible}")

                if upd.kind == "quit":
                    print("[win_overlay] Recibido quit, destruyendo ventana")
                    try:
                        win32gui.DestroyWindow(hwnd)
                    except Exception:
                        pass
                    return
                if upd.text is not None:
                    self._text = upd.text
                    print(f"[win_overlay] Texto actualizado: '{self._text}'")
                    dirty = True
                if upd.level is not None:
                    self._level = max(0.0, min(upd.level, 1.0))
                    dirty = True
                if upd.visible is not None:
                    self._visible = bool(upd.visible)
                    print(f"[win_overlay] Cambiando visible a: {self._visible}")
                    if self._visible:
                        # Ensure correct position and show without activating.
                        x, y, w, h = self._initial_rect()
                        print(f"[win_overlay] Mostrando ventana en: x={x}, y={y}, w={w}, h={h}")
                        try:
                            win32gui.SetWindowPos(
                                hwnd,
                                win32con.HWND_TOPMOST,
                                x,
                                y,
                                w,
                                h,
                                win32con.SWP_NOACTIVATE | win32con.SWP_SHOWWINDOW,
                            )
                            print("[win_overlay] SetWindowPos ejecutado OK")
                        except Exception as e:
                            print(f"[win_overlay] ERROR en SetWindowPos: {e}")
                        try:
                            win32gui.ShowWindow(hwnd, win32con.SW_SHOWNA)
                            print("[win_overlay] ShowWindow(SW_SHOWNA) ejecutado OK")
                            win32gui.BringWindowToTop(hwnd)
                            print("[win_overlay] BringWindowToTop ejecutado OK")
                            win32gui.UpdateWindow(hwnd)
                            print("[win_overlay] UpdateWindow ejecutado OK")
                        except Exception as e:
                            print(f"[win_overlay] ERROR en Show/Bring/Update: {e}")
                    else:
                        print("[win_overlay] Ocultando ventana")
                        win32gui.ShowWindow(hwnd, win32con.SW_HIDE)
                    dirty = True
        except queue.Empty:
            pass
        except Exception as e:
            print(f"[win_overlay] ERROR en _drain_updates: {e}")
        if dirty and self._visible:
            try:
                print("[win_overlay] Llamando InvalidateRect para repintar")
                win32gui.InvalidateRect(hwnd, None, True)
            except Exception as e:
                print(f"[win_overlay] ERROR en InvalidateRect: {e}")

    def _on_paint(self, hwnd: int) -> None:
        assert win32gui is not None and win32con is not None
        hdc, paint_struct = win32gui.BeginPaint(hwnd)
        try:
            rect = win32gui.GetClientRect(hwnd)
            w = rect[2] - rect[0]
            h = rect[3] - rect[1]

            # Background
            bg = win32gui.CreateSolidBrush(win32api.RGB(18, 18, 18))
            win32gui.FillRect(hdc, rect, bg)
            win32gui.DeleteObject(bg)

            # Accent top border for visibility
            border = win32gui.CreateSolidBrush(win32api.RGB(0, 255, 136))
            win32gui.FillRect(hdc, (0, 0, w, 2), border)
            win32gui.DeleteObject(border)

            # Text
            win32gui.SetBkMode(hdc, win32con.TRANSPARENT)
            win32gui.SetTextColor(hdc, win32api.RGB(255, 255, 255))
            text_rect = (16, 8, w - 16, 26)
            win32gui.DrawText(
                hdc,
                self._text or "",
                -1,
                text_rect,
                win32con.DT_LEFT | win32con.DT_VCENTER | win32con.DT_SINGLELINE | win32con.DT_END_ELLIPSIS,
            )

            # Level bar
            bar_left = 16
            bar_top = 30
            bar_right = w - 16
            bar_bottom = 40
            # Background
            bar_bg = win32gui.CreateSolidBrush(win32api.RGB(31, 31, 31))
            win32gui.FillRect(hdc, (bar_left, bar_top, bar_right, bar_bottom), bar_bg)
            win32gui.DeleteObject(bar_bg)
            # Fill
            fill_w = int((bar_right - bar_left) * max(0.0, min(self._level, 1.0)))
            if fill_w > 0:
                bar_fill = win32gui.CreateSolidBrush(win32api.RGB(0, 255, 136))
                win32gui.FillRect(hdc, (bar_left, bar_top, bar_left + fill_w, bar_bottom), bar_fill)
                win32gui.DeleteObject(bar_fill)
        finally:
            win32gui.EndPaint(hwnd, paint_struct)
