"""
Modern settings window using CustomTkinter.

CustomTkinter provides modern UI components with rounded corners,
smooth animations, and professional dark themes.
"""

from __future__ import annotations

import json
import threading
import subprocess
import os
import sys
import logging
from pathlib import Path
from typing import Any, Dict, List, Optional
from datetime import datetime

import customtkinter as ctk
from tkinter import messagebox, PhotoImage
try:
    from PIL import Image, ImageTk
    PIL_AVAILABLE = True
except ImportError:
    PIL_AVAILABLE = False

try:
    import sounddevice as sd  # type: ignore
except ImportError:  # pragma: no cover
    sd = None

try:
    import requests  # type: ignore
except ImportError:  # pragma: no cover
    requests = None


# Premium dark theme with neon green - inspired by high-end audio software
COLORS = {
    # Backgrounds with depth
    "bg": "#080808",           # Deeper black for more contrast
    "bg_secondary": "#0d0d0d", # Subtle lift
    "panel": "#111111",        # Sidebar with subtle difference
    "panel_hover": "#1a1a1a",  # Hover state

    # Neon green system (primary color)
    "accent": "#00ff88",       # Electric neon green - brand color
    "accent_glow": "rgba(0, 255, 136, 0.15)",  # Glow effect
    "accent_hover": "#00ffaa", # Brighter on hover
    "accent_dim": "#00aa55",   # Dimmed for inactive
    "accent_border": "rgba(0, 255, 136, 0.3)", # Glowing borders

    # Text hierarchy
    "text": "#ffffff",         # Pure white for primary text
    "text_secondary": "#b0b0b0", # Mid-gray for secondary
    "text_dim": "#707070",     # Dimmed for tertiary

    # Surfaces and borders
    "border": "#1f1f1f",       # Subtle borders
    "card_bg": "#0f0f0f",      # Cards slightly lifted from bg
    "card_border": "#1a1a1a",  # Card borders

    # Functional colors
    "success": "#00ff88",      # Same as accent
    "danger": "#ff4444",       # For delete actions
    "warning": "#ffaa00",      # For warnings
}

MAX_MODELS_SHOWN = 50
DEFAULT_MODELS_PATH = Path(__file__).resolve().parent.parent / "resources" / "models_default.json"

LLM_SYSTEM_PROMPT = (
    "You are \"Transcription 2.0\": a real-time dictation post-editor.\n\n"
    "Task:\n"
    "- Take the user’s raw speech-to-text transcript and return the same content as clean written text.\n\n"
    "Absolute output rules:\n"
    "- Output ONLY the transformed text. No titles, no prefixes (do NOT write \"Transcription 2.0\", do NOT write \"Here is...\", do NOT add any header), no explanations, no markdown wrappers.\n"
    "- Keep the SAME language as the transcript. Do NOT translate.\n"
    "- Preserve meaning strictly. Do NOT add new ideas, facts, steps, names, or assumptions.\n"
    "- If something is unclear or contradictory, do not \"fix\" it conceptually—only improve punctuation/structure while keeping the same content.\n"
    "- Be efficient: make the smallest changes that achieve a clean result.\n\n"
    "Technical safety (critical):\n"
    "- Preserve technical tokens literally: identifiers, casing, paths, URLs, emails, IDs, versions, flags, env vars, JSON/YAML keys, stack traces, code symbols.\n"
    "- Never spell-correct a technical term into a common word.\n"
    "- Never change casing inside identifiers (camelCase/snake_case/PascalCase/kebab-case).\n"
    "- If unsure whether a substring is technical, assume it IS technical and keep it unchanged.\n\n"
    "Speech cleanup:\n"
    "- Remove fillers and speech artifacts (um/uh/like/you know), stutters, false starts, and obvious repetitions when removal does not change meaning.\n"
    "- Keep intentional emphasis.\n\n"
    "Formatting & structure (very important):\n"
    "- Add punctuation and capitalization.\n"
    "- Split into short paragraphs when the topic changes.\n"
    "- Aggressively convert spoken enumerations into lists:\n"
    "  - If the transcript contains multiple items, requirements, steps, options, pros/cons, or comparisons, format them as a bullet list.\n"
    "  - If it is a procedure, format as numbered steps.\n"
    "  - If it is categories with subpoints, use nested bullets.\n"
    "- Keep lists readable: 1 idea per bullet, minimal fluff.\n\n"
    "Spoken token normalization (ONLY when obvious):\n"
    "- \"comma\" -> ,\n"
    "- \"period/full stop\" -> .\n"
    "- \"colon\" -> :\n"
    "- \"semicolon\" -> ;\n"
    "- \"new line/newline\" -> line break\n"
    "- \"open/close paren\" -> ( )\n"
    "- \"open/close bracket\" -> [ ]\n"
    "- \"open/close brace\" -> { }\n"
    "- \"quote/end quote\" -> \"\n"
    "- \"backtick\" -> `\n"
    "- \"underscore\" -> _\n"
    "- \"dash dash\" -> --\n"
    "- \"slash\" -> / ; \"backslash\" -> \\\n"
    "- \"dot\" -> . ONLY inside domains, filenames/extensions, versions, or identifiers where clearly intended\n\n"
    "Code / CLI handling:\n"
    "Detect code/CLI/config/logs if there are strong signals (e.g., {}, (), =>, ;, --flag, $, npm, pnpm, pip, git, JSON/YAML-like lines, stack traces).\n"
    "- Preserve symbols and whitespace.\n"
    "- Do NOT refactor or beautify code semantics.\n"
    "- Use fenced code blocks ONLY if the transcript clearly contains multi-line code/CLI/config/output. Otherwise keep inline.\n\n"
    "Optional personal vocabulary:\n"
    "- If the user includes a line like:\n"
    "  DICTIONARY: term1, term2, term3\n"
    "  then those terms must be preserved exactly as written (case-sensitive).\n\n"
    "Fail-safe:\n"
    "- When uncertain about a change, keep the original substring.\n"
    "- Never output anything except the final transformed text."
)


def _load_config(path: Path) -> Dict[str, Any]:
    try:
        return json.loads(path.read_text(encoding="utf-8"))
    except Exception:
        return {}


def _load_default_models(path: Path, fallback: List[str]) -> List[str]:
    try:
        data = json.loads(path.read_text(encoding="utf-8"))
        if isinstance(data, list):
            return [str(x) for x in data if x]
    except Exception:
        pass
    return list(fallback)


def _save_config(path: Path, data: Dict[str, Any]) -> None:
    path.write_text(json.dumps(data, indent=2), encoding="utf-8")


class ModernSettingsWindow:
    def __init__(self, config_path: Path, history_manager=None) -> None:
        self.config_path = config_path
        self.data = _load_config(config_path)
        self.history_manager = history_manager
        self.default_models: List[str] = self._load_default_models()
        self.user_models: List[str] = []
        self.model_options: List[str] = list(self.default_models)
        self.model_all: List[str] = list(self.default_models)
        self._current_model_cfg = None

        # Configure CustomTkinter appearance
        ctk.set_appearance_mode("dark")
        # Don't set color theme - we use custom colors

        # Create main window
        self.root = ctk.CTk()
        self.root.title("Whisper Cheap")
        self.root.geometry("1200x800")
        self.root.configure(fg_color=COLORS["bg"])

        # Try to load custom fonts (Outfit for headings)
        self._load_custom_fonts()

        # Set window icon (for taskbar and title bar)
        # Windows needs BOTH iconbitmap() AND iconphoto() for proper display
        try:
            # Use high-res PNG (256x256) with iconphoto() for taskbar (Windows 10+)
            icon_png_path = Path(__file__).resolve().parent.parent / "resources" / "icons" / "idle_256.png"
            if icon_png_path.exists() and PIL_AVAILABLE:
                logging.info(f"[ICON] Loading high-res PNG icon for taskbar: {icon_png_path}")
                icon_img = Image.open(icon_png_path)
                icon_photo = ImageTk.PhotoImage(icon_img)
                self.root.iconphoto(True, icon_photo)  # True = default for all toplevels
                self._icon_photo_ref = icon_photo  # Keep reference
                logging.info(f"[ICON] High-res PNG icon set via iconphoto()")

            # Also use .ico for title bar (Windows compatibility)
            icon_ico_path = Path(__file__).resolve().parent.parent / "resources" / "icons" / "app.ico"
            if icon_ico_path.exists():
                logging.info(f"[ICON] Loading ICO for title bar: {icon_ico_path}")
                self.root.iconbitmap(str(icon_ico_path))
                logging.info(f"[ICON] ICO set via iconbitmap()")
            else:
                logging.warning(f"[ICON] Icon file not found: {icon_ico_path}")
        except Exception as e:
            logging.error(f"[ICON] Failed to set icon: {e}", exc_info=True)

        # Storage for widgets and images (prevent garbage collection)
        self.section_frames: Dict[str, ctk.CTkFrame] = {}
        self.nav_buttons: Dict[str, ctk.CTkButton] = {}
        self.vars: Dict[str, Any] = {}
        self.model_status = ctk.StringVar(value="Model list: default")
        self.vars["model_search"] = ctk.StringVar()
        self.test_status = ctk.StringVar(value="")
        self.vars["add_model"] = ctk.StringVar()
        self._logo_pil_image = None  # Keep PIL image reference
        self._logo_image = None  # Keep CTkImage reference to prevent garbage collection
        self._icon_photo_ref = None  # Keep window icon reference

        self._build_layout()
        self._build_sections()
        self._populate()
        self._show_section("General")

    def _build_layout(self):
        """Build the main layout with sidebar navigation and content area"""
        # Main container with padding
        container = ctk.CTkFrame(self.root, fg_color="transparent")
        container.pack(fill="both", expand=True, padx=24, pady=24)

        # Left sidebar
        sidebar = ctk.CTkFrame(container, width=240, fg_color=COLORS["panel"], corner_radius=16)
        sidebar.pack(side="left", fill="y", padx=(0, 28))
        sidebar.pack_propagate(False)

        # Header with logo and branding
        header_frame = ctk.CTkFrame(sidebar, fg_color="transparent")
        header_frame.pack(fill="x", padx=20, pady=(20, 32))

        # Logo image + text layout
        logo_container = ctk.CTkFrame(header_frame, fg_color="transparent")
        logo_container.pack(anchor="w", fill="x")

        # Load and display logo image
        try:
            logo_path = Path(__file__).resolve().parent.parent / "resources" / "icons" / "idle.png"
            if logo_path.exists() and PIL_AVAILABLE:
                # Load and resize image
                self._logo_pil_image = Image.open(logo_path)
                self._logo_pil_image = self._logo_pil_image.resize((56, 56), Image.Resampling.LANCZOS)

                # Use CTkImage for proper HighDPI support
                self._logo_image = ctk.CTkImage(light_image=self._logo_pil_image, dark_image=self._logo_pil_image, size=(56, 56))

                logo_label = ctk.CTkLabel(logo_container, image=self._logo_image, text="")
                logo_label.pack(side="left", padx=(0, 12))
        except Exception as e:
            pass

        # Text branding
        text_frame = ctk.CTkFrame(logo_container, fg_color="transparent")
        text_frame.pack(side="left", fill="both", expand=True)

        title = ctk.CTkLabel(
            text_frame,
            text="WHISPER",
            font=("JetBrains Mono", 14, "bold"),
            text_color=COLORS["accent"]
        )
        title.pack(anchor="w")

        subtitle_app = ctk.CTkLabel(
            text_frame,
            text="CHEAP",
            font=("JetBrains Mono", 11, "bold"),
            text_color=COLORS["text"]
        )
        subtitle_app.pack(anchor="w")

        # Divider line
        divider = ctk.CTkFrame(header_frame, height=2, fg_color=COLORS["accent"])
        divider.pack(fill="x", pady=(12, 0))

        # Navigation buttons with icons - BOLD typography
        nav_items = [
            ("General", "[ ] GENERAL"),
            ("Audio", "[ ] AUDIO"),
            ("Overlay", "[ ] OVERLAY"),
            ("Post", "[ ] POST-PROCESSING"),
            ("History", "[ ] HISTORY"),
            ("About", "[ ] ABOUT")
        ]

        for name, label in nav_items:
            btn = ctk.CTkButton(
                sidebar,
                text=label,
                font=("JetBrains Mono", 14, "bold"),
                fg_color="transparent",
                text_color=COLORS["text_dim"],
                hover_color=COLORS["panel_hover"],
                corner_radius=12,
                height=52,
                anchor="w",
                command=lambda n=name: self._show_section(n)
            )
            btn.pack(fill="x", padx=16, pady=4)
            self.nav_buttons[name] = btn

        # Content area
        self.content = ctk.CTkScrollableFrame(
            container,
            fg_color="transparent",
            scrollbar_button_color=COLORS["panel"],
            scrollbar_button_hover_color=COLORS["panel_hover"]
        )
        self.content.pack(side="left", fill="both", expand=True)

    def _build_sections(self):
        """Build all settings sections"""
        self._build_general()
        self._build_audio()
        self._build_overlay()
        self._build_post()
        self._build_history()
        self._build_about()

    def _load_default_models(self) -> List[str]:
        return _load_default_models(
            DEFAULT_MODELS_PATH,
            fallback=[
                "openai/gpt-oss-20b",
                "openai/gpt-5-nano",
                "google/gemini-2.5-flash-lite",
                "mistralai/mistral-small-3.2-24b-instruct",
            ],
        )

    def _build_card(self, parent, title: str) -> ctk.CTkFrame:
        """Create a card container with title"""
        card = ctk.CTkFrame(parent, fg_color=COLORS["card_bg"], corner_radius=20, border_width=0)
        card.pack(fill="x", pady=(0, 20))

        # Title with green accent bar
        title_container = ctk.CTkFrame(card, fg_color="transparent")
        title_container.pack(fill="x", padx=28, pady=(24, 20))

        accent_bar = ctk.CTkFrame(title_container, width=4, height=24, fg_color=COLORS["accent"], corner_radius=2)
        accent_bar.pack(side="left", padx=(0, 12))

        title_label = ctk.CTkLabel(
            title_container,
            text=title.upper(),
            font=("JetBrains Mono", 20, "bold"),
            text_color=COLORS["text"]
        )
        title_label.pack(side="left")

        return card

    def _build_general(self):
        frame = ctk.CTkFrame(self.content, fg_color="transparent")
        self.section_frames["General"] = frame

        card = self._build_card(frame, "General")
        content = ctk.CTkFrame(card, fg_color="transparent")
        content.pack(fill="x", padx=24, pady=(0, 20))

        # Hotkey with capture button
        row = ctk.CTkFrame(content, fg_color="transparent")
        row.pack(fill="x", pady=(0, 16))
        ctk.CTkLabel(row, text="Hotkey", font=("JetBrains Mono", 14, "bold"), text_color=COLORS["text"], width=160, anchor="w").pack(side="left", padx=(0, 16))
        self.vars["hotkey"] = ctk.StringVar()
        self.hotkey_entry = ctk.CTkEntry(row, textvariable=self.vars["hotkey"], width=220, height=44, corner_radius=10, font=("JetBrains Mono", 14), border_width=0, fg_color=COLORS["panel"], state="readonly")
        self.hotkey_entry.pack(side="left", padx=(0, 12))
        self.hotkey_capture_btn = ctk.CTkButton(row, text="Record", command=self._start_hotkey_capture, width=100, height=44, corner_radius=10, font=("JetBrains Mono", 12, "bold"), fg_color=COLORS["accent"], hover_color=COLORS["accent_hover"], text_color="#000000")
        self.hotkey_capture_btn.pack(side="left")
        self.capturing_hotkey = False
        self.captured_keys = []

        # Activation mode
        row = ctk.CTkFrame(content, fg_color="transparent")
        row.pack(fill="x", pady=(0, 16))
        ctk.CTkLabel(row, text="Mode", font=("JetBrains Mono", 14, "bold"), text_color=COLORS["text"], width=160, anchor="w").pack(side="left", padx=(0, 16))
        self.vars["activation_mode"] = ctk.StringVar()
        mode_frame = ctk.CTkFrame(row, fg_color="transparent")
        mode_frame.pack(side="left")
        rb1 = ctk.CTkRadioButton(mode_frame, text="Push-to-Talk", variable=self.vars["activation_mode"], value="ptt", font=("JetBrains Mono", 13), command=self._auto_save, fg_color=COLORS["accent"], hover_color=COLORS["accent_hover"])
        rb1.pack(side="left", padx=(0, 20))
        rb2 = ctk.CTkRadioButton(mode_frame, text="Toggle", variable=self.vars["activation_mode"], value="toggle", font=("JetBrains Mono", 13), command=self._auto_save, fg_color=COLORS["accent"], hover_color=COLORS["accent_hover"])
        rb2.pack(side="left")

        # Start on boot (checked by default)
        row = ctk.CTkFrame(content, fg_color="transparent")
        row.pack(fill="x", pady=(0, 16))
        start_on_boot_default = bool(self.data.get("general", {}).get("start_on_boot", False))
        self.vars["start_on_boot"] = ctk.BooleanVar(value=start_on_boot_default)
        cb = ctk.CTkCheckBox(row, text="Start on Windows boot", variable=self.vars["start_on_boot"], font=("JetBrains Mono", 13), command=self._auto_save, fg_color=COLORS["accent"], hover_color=COLORS["accent_hover"])
        cb.pack(side="left")

        # Paste method - HIDDEN (keep internal logic, no UI)
        self.vars["paste_method"] = ctk.StringVar(value="ctrl_v")  # Keep default internally

        # Clipboard policy (default: copy_to_clipboard)
        row = ctk.CTkFrame(content, fg_color="transparent")
        row.pack(fill="x", pady=(0, 16))
        ctk.CTkLabel(row, text="Clipboard", font=("JetBrains Mono", 14, "bold"), text_color=COLORS["text"], width=160, anchor="w").pack(side="left", padx=(0, 16))
        self.vars["clipboard_policy"] = ctk.StringVar(value="copy_to_clipboard")  # Default copy_to_clipboard
        combo = ctk.CTkComboBox(row, variable=self.vars["clipboard_policy"], values=["dont_modify", "copy_to_clipboard"], width=220, height=44, corner_radius=10, font=("JetBrains Mono", 13), command=lambda x: self._auto_save(), border_width=0, fg_color=COLORS["panel"], button_color=COLORS["accent"], button_hover_color=COLORS["accent_hover"])
        combo.pack(side="left")

    def _build_audio(self):
        frame = ctk.CTkFrame(self.content, fg_color="transparent")
        self.section_frames["Audio"] = frame

        card = self._build_card(frame, "Audio")
        content = ctk.CTkFrame(card, fg_color="transparent")
        content.pack(fill="x", padx=28, pady=(0, 24))

        # Microphone (only this field, no refresh button)
        row = ctk.CTkFrame(content, fg_color="transparent")
        row.pack(fill="x", pady=(0, 16))
        ctk.CTkLabel(row, text="Microphone", font=("JetBrains Mono", 14, "bold"), text_color=COLORS["text"], width=160, anchor="w").pack(side="left", padx=(0, 16))
        self.vars["device_id"] = ctk.StringVar()
        self.device_box = ctk.CTkComboBox(row, variable=self.vars["device_id"], width=360, height=44, corner_radius=10, font=("JetBrains Mono", 13), border_width=0, fg_color=COLORS["panel"], button_color=COLORS["accent"], button_hover_color=COLORS["accent_hover"], command=lambda x: self._auto_save())
        self.device_box.pack(side="left")

        # Hidden vars (keep internal logic but don't show UI)
        self.vars["use_vad"] = ctk.BooleanVar(value=False)
        self.vars["vad_threshold"] = ctk.DoubleVar(value=0.5)
        self.vars["mute_while_recording"] = ctk.BooleanVar(value=False)
        self.vars["chunk_size"] = ctk.StringVar(value="4096")

    def _build_overlay(self):
        frame = ctk.CTkFrame(self.content, fg_color="transparent")
        self.section_frames["Overlay"] = frame

        card = self._build_card(frame, "Overlay")
        content = ctk.CTkFrame(card, fg_color="transparent")
        content.pack(fill="x", padx=28, pady=(0, 24))

        # Enable overlay
        row = ctk.CTkFrame(content, fg_color="transparent")
        row.pack(fill="x", pady=(0, 16))
        self.vars["overlay_enabled"] = ctk.BooleanVar()
        ctk.CTkCheckBox(row, text="Show overlay", variable=self.vars["overlay_enabled"], font=("JetBrains Mono", 13), command=self._auto_save, fg_color=COLORS["accent"], hover_color=COLORS["accent_hover"]).pack(side="left")

        # Position
        row = ctk.CTkFrame(content, fg_color="transparent")
        row.pack(fill="x", pady=(0, 16))
        ctk.CTkLabel(row, text="Position", font=("JetBrains Mono", 14, "bold"), text_color=COLORS["text"], width=160, anchor="w").pack(side="left", padx=(0, 16))
        self.vars["overlay_position"] = ctk.StringVar()
        ctk.CTkComboBox(row, variable=self.vars["overlay_position"], values=["bottom", "top"], width=220, height=44, corner_radius=10, font=("JetBrains Mono", 13), border_width=0, fg_color=COLORS["panel"], button_color=COLORS["accent"], button_hover_color=COLORS["accent_hover"], command=lambda x: self._auto_save()).pack(side="left")

        # Opacity
        row = ctk.CTkFrame(content, fg_color="transparent")
        row.pack(fill="x", pady=(0, 16))
        ctk.CTkLabel(row, text="Opacity", font=("JetBrains Mono", 14, "bold"), text_color=COLORS["text"], width=160, anchor="w").pack(side="left", padx=(0, 16))
        self.vars["overlay_opacity"] = ctk.DoubleVar()
        ctk.CTkSlider(row, from_=0.5, to=1.0, variable=self.vars["overlay_opacity"], width=280, fg_color=COLORS["panel"], progress_color=COLORS["accent"], button_color=COLORS["accent"], button_hover_color=COLORS["accent_hover"], command=lambda x: self._auto_save()).pack(side="left")

    def _build_post(self):
        frame = ctk.CTkFrame(self.content, fg_color="transparent")
        self.section_frames["Post"] = frame

        card = self._build_card(frame, "AI Process")
        content = ctk.CTkFrame(card, fg_color="transparent")
        content.pack(fill="x", padx=28, pady=(0, 24))

        # Enable
        row = ctk.CTkFrame(content, fg_color="transparent")
        row.pack(fill="x", pady=(0, 16))
        self.vars["pp_enabled"] = ctk.BooleanVar()
        ctk.CTkCheckBox(row, text="Enable AI post-processing", variable=self.vars["pp_enabled"], font=("JetBrains Mono", 13), command=self._auto_save, fg_color=COLORS["accent"], hover_color=COLORS["accent_hover"]).pack(side="left")

        # API Key (OpenRouter)
        row = ctk.CTkFrame(content, fg_color="transparent")
        row.pack(fill="x", pady=(0, 16))
        ctk.CTkLabel(row, text="OpenRouter API Key", font=("JetBrains Mono", 14, "bold"), text_color=COLORS["text"], width=180, anchor="w").pack(side="left", padx=(0, 16))
        self.vars["pp_api_key"] = ctk.StringVar()
        entry = ctk.CTkEntry(row, textvariable=self.vars["pp_api_key"], width=380, height=44, corner_radius=10, font=("JetBrains Mono", 13), show="*", border_width=0, fg_color=COLORS["panel"])
        entry.pack(side="left")
        entry.bind("<KeyRelease>", lambda e: self._auto_save())

        # Model selector (popular OpenRouter models)
        row = ctk.CTkFrame(content, fg_color="transparent")
        row.pack(fill="x", pady=(0, 16))
        ctk.CTkLabel(row, text="Model", font=("JetBrains Mono", 14, "bold"), text_color=COLORS["text"], width=180, anchor="w").pack(side="left", padx=(0, 16))
        self.vars["pp_model"] = ctk.StringVar()
        # Filter + reset + refresh in one row
        filter_row = ctk.CTkFrame(content, fg_color="transparent")
        filter_row.pack(fill="x", pady=(0, 12))
        ctk.CTkLabel(filter_row, text="Filter", font=("JetBrains Mono", 12), text_color=COLORS["text_dim"], width=60, anchor="w").pack(side="left", padx=(0, 8))
        search_entry = ctk.CTkEntry(filter_row, textvariable=self.vars["model_search"], width=200, height=36, corner_radius=10, font=("JetBrains Mono", 12), border_width=0, fg_color=COLORS["panel"])
        search_entry.pack(side="left", padx=(0, 8))
        search_entry.bind("<KeyRelease>", lambda e: self._filter_models(self.vars["model_search"].get()))
        ctk.CTkButton(filter_row, text="Reset defaults", width=120, height=36, corner_radius=10, font=("JetBrains Mono", 12, "bold"), fg_color=COLORS["panel"], hover_color=COLORS["panel_hover"], command=self._reset_models).pack(side="left", padx=(8, 8))
        ctk.CTkButton(filter_row, text="Refresh", width=90, height=36, corner_radius=10, font=("JetBrains Mono", 12, "bold"), fg_color=COLORS["panel"], hover_color=COLORS["panel_hover"], command=self._refresh_models_async).pack(side="left")

        # Scrollable list of models
        self.model_list_frame = ctk.CTkScrollableFrame(content, fg_color=COLORS["panel"], height=200, border_width=0)
        self.model_list_frame.pack(fill="x", pady=(0, 12))

        status_row = ctk.CTkFrame(content, fg_color="transparent")
        status_row.pack(fill="x", pady=(0, 8))
        ctk.CTkLabel(status_row, textvariable=self.model_status, font=("JetBrains Mono", 12), text_color=COLORS["text_dim"], anchor="w").pack(side="left", padx=(0, 8))

        test_row = ctk.CTkFrame(content, fg_color="transparent")
        test_row.pack(fill="x", pady=(0, 12))
        ctk.CTkButton(
            test_row,
            text="Test connection",
            width=160,
            height=40,
            corner_radius=10,
            font=("JetBrains Mono", 12, "bold"),
            fg_color=COLORS["panel"],
            hover_color=COLORS["panel_hover"],
            command=self._test_llm_connection,
        ).pack(side="left", padx=(0, 16))
        ctk.CTkLabel(test_row, textvariable=self.test_status, font=("JetBrains Mono", 12), text_color=COLORS["text_dim"], anchor="w").pack(side="left")

        manage_row = ctk.CTkFrame(content, fg_color="transparent")
        manage_row.pack(fill="x", pady=(0, 12))
        add_entry = ctk.CTkEntry(manage_row, textvariable=self.vars["add_model"], width=260, height=36, corner_radius=10, font=("JetBrains Mono", 12), border_width=0, fg_color=COLORS["panel"])
        add_entry.pack(side="left", padx=(0, 8))
        ctk.CTkButton(manage_row, text="+ Add model", width=120, height=36, corner_radius=10, font=("JetBrains Mono", 12, "bold"), fg_color=COLORS["accent"], hover_color=COLORS["accent_hover"], text_color="#000000", command=self._add_model).pack(side="left", padx=(0, 8))

        # Prompt template (editable)
        # Prompt template is fixed and not user-editable

    def _build_history(self):
        frame = ctk.CTkFrame(self.content, fg_color="transparent")
        self.section_frames["History"] = frame

        # Toolbar
        toolbar = ctk.CTkFrame(frame, fg_color="transparent")
        toolbar.pack(fill="x", pady=(0, 20))

        ctk.CTkLabel(toolbar, text="RECENT TRANSCRIPTIONS", font=("JetBrains Mono", 20, "bold"), text_color=COLORS["text"]).pack(side="left")

        btn_group = ctk.CTkFrame(toolbar, fg_color="transparent")
        btn_group.pack(side="right")
        ctk.CTkButton(btn_group, text="Open folder", command=self._open_recordings_folder, width=140, height=44, corner_radius=12, font=("JetBrains Mono", 13, "bold"), fg_color=COLORS["panel"], hover_color=COLORS["panel_hover"], border_width=0).pack(side="left", padx=(0, 12))
        ctk.CTkButton(btn_group, text="Refresh", command=self._refresh_history, width=140, height=44, corner_radius=12, font=("JetBrains Mono", 13, "bold"), fg_color=COLORS["accent"], hover_color=COLORS["accent_hover"], text_color="#000000").pack(side="left")

        # History cards container (scrollable)
        self.history_cards_frame = ctk.CTkScrollableFrame(frame, fg_color="transparent", height=550)
        self.history_cards_frame.pack(fill="both", expand=True)

    def _build_about(self):
        frame = ctk.CTkFrame(self.content, fg_color="transparent")
        self.section_frames["About"] = frame

        card = self._build_card(frame, "About")
        content = ctk.CTkFrame(card, fg_color="transparent")
        content.pack(fill="x", padx=28, pady=(0, 24))

        ctk.CTkLabel(content, text="Whisper Cheap", font=("JetBrains Mono", 20, "bold"), text_color=COLORS["text"]).pack(anchor="w", pady=(0, 8))
        ctk.CTkLabel(content, text="Version: 1.0.0", font=("JetBrains Mono", 13), text_color=COLORS["text_dim"]).pack(anchor="w", pady=(0, 4))
        ctk.CTkLabel(content, text="Local voice transcription with Parakeet V3", font=("JetBrains Mono", 13), text_color=COLORS["text_dim"]).pack(anchor="w", pady=(0, 24))

        btn_frame = ctk.CTkFrame(content, fg_color="transparent")
        btn_frame.pack(fill="x")
        ctk.CTkButton(btn_frame, text="Open Data Folder", command=self._open_app_data_folder, width=200, height=44, corner_radius=12, font=("JetBrains Mono", 13, "bold"), fg_color=COLORS["accent"], hover_color=COLORS["accent_hover"], text_color="#000000").pack(side="left", padx=(0, 12))
        ctk.CTkButton(btn_frame, text="Open Recordings", command=self._open_recordings_folder, width=200, height=44, corner_radius=12, font=("JetBrains Mono", 13, "bold"), fg_color=COLORS["accent"], hover_color=COLORS["accent_hover"], text_color="#000000").pack(side="left")

    def _start_hotkey_capture(self):
        """Start capturing hotkey presses"""
        if self.capturing_hotkey:
            return

        self.capturing_hotkey = True
        self.captured_keys = []
        self.hotkey_capture_btn.configure(text="Press keys...", fg_color=COLORS["accent_dim"])
        self.vars["hotkey"].set("Press keys...")

        # Bind key events to capture
        self.root.bind("<KeyPress>", self._on_hotkey_press)
        self.root.focus_set()

    def _on_hotkey_press(self, event):
        """Capture key presses for hotkey"""
        if not self.capturing_hotkey:
            return

        # Map special keys
        key = event.keysym.lower()
        if key in ['control_l', 'control_r']:
            key = 'ctrl'
        elif key in ['shift_l', 'shift_r']:
            key = 'shift'
        elif key in ['alt_l', 'alt_r']:
            key = 'alt'

        # Add key if not already in list
        if key not in self.captured_keys:
            self.captured_keys.append(key)

        # Show current combination
        hotkey_str = "+".join(self.captured_keys)
        self.vars["hotkey"].set(hotkey_str)

        # If user presses Return/Enter, confirm the hotkey
        if key == 'return':
            self._confirm_hotkey()

    def _confirm_hotkey(self):
        """Confirm and save the captured hotkey"""
        self.capturing_hotkey = False
        self.root.unbind("<KeyPress>")

        # Remove 'return' from captured keys if present
        if 'return' in self.captured_keys:
            self.captured_keys.remove('return')

        # Build final hotkey string
        if self.captured_keys:
            hotkey_str = "+".join(self.captured_keys)
            self.vars["hotkey"].set(hotkey_str)
            self._auto_save()
        else:
            # Restore previous value if no keys captured
            self.vars["hotkey"].set(self.data.get("hotkey", "ctrl+shift+space"))

        self.hotkey_capture_btn.configure(text="Record", fg_color=COLORS["accent"])

    def _auto_save(self):
        """Auto-save configuration when any setting changes"""
        threading.Timer(0.5, self._save_config_silent).start()

    def _save_config_silent(self):
        """Save config without closing the window"""
        try:
            d = self.data
            self._current_model_cfg = self.vars["pp_model"].get().strip()

            # General
            d["hotkey"] = self.vars["hotkey"].get().strip() or "ctrl+shift+space"
            general = d.setdefault("general", {})
            general["start_on_boot"] = bool(self.vars["start_on_boot"].get())

            # Mode
            d.setdefault("mode", {})["activation_mode"] = self.vars["activation_mode"].get().strip() or "toggle"

            # Audio
            audio = d.setdefault("audio", {})
            dev_val = self.vars["device_id"].get().strip()
            if dev_val.lower() == "default" or dev_val == "":
                audio["device_id"] = None
            elif dev_val and ":" in dev_val and dev_val.split(":")[0].strip().isdigit():
                audio["device_id"] = int(dev_val.split(":")[0].strip())
            else:
                audio["device_id"] = dev_val
            try:
                audio["chunk_size"] = int(self.vars["chunk_size"].get())
            except Exception:
                audio["chunk_size"] = 4096
            audio["use_vad"] = bool(self.vars["use_vad"].get())
            try:
                audio["vad_threshold"] = float(self.vars["vad_threshold"].get())
            except Exception:
                audio["vad_threshold"] = 0.5
            audio["mute_while_recording"] = bool(self.vars["mute_while_recording"].get())

            # Clipboard
            clip = d.setdefault("clipboard", {})
            clip["paste_method"] = self.vars["paste_method"].get() or "ctrl_v"
            clip["policy"] = self.vars["clipboard_policy"].get() or "dont_modify"

            # Overlay
            overlay = d.setdefault("overlay", {})
            overlay["enabled"] = bool(self.vars["overlay_enabled"].get())
            overlay["position"] = self.vars["overlay_position"].get() or "bottom"
            try:
                overlay["opacity"] = float(self.vars["overlay_opacity"].get())
            except Exception:
                overlay["opacity"] = 0.85

            # Post-processing (prompt is fixed)
            pp = d.setdefault("post_processing", {})
            pp["enabled"] = bool(self.vars["pp_enabled"].get())
            pp["openrouter_api_key"] = self.vars["pp_api_key"].get().strip()
            pp["model"] = self.vars["pp_model"].get().strip()
            pp["prompt_template"] = "Transcript:\\n${output}"
            pp["custom_models"] = list(self.user_models)

            _save_config(self.config_path, d)
        except Exception as e:
            print(f"Error al guardar config: {e}")

    # ---------- data ----------
    def _populate(self):
        d = self.data
        general = d.get("general", {})
        mode = d.get("mode", {})
        audio = d.get("audio", {})
        clip = d.get("clipboard", {})
        overlay = d.get("overlay", {})
        pp = d.get("post_processing", {})
        history = d.get("history", {})

        # General
        self.vars["hotkey"].set(d.get("hotkey", "ctrl+shift+space"))
        self.vars["activation_mode"].set(mode.get("activation_mode", "toggle"))
        self.vars["start_on_boot"].set(bool(general.get("start_on_boot", False)))
        self.vars["paste_method"].set(clip.get("paste_method", "ctrl_v"))
        self.vars["clipboard_policy"].set(clip.get("policy", "dont_modify"))

        # Audio
        dev = audio.get("device_id")
        self.vars["device_id"].set("" if dev is None else str(dev))
        # Hidden vars set defaults (no UI to populate)
        self.vars["chunk_size"].set(str(audio.get("chunk_size", 4096)))
        self.vars["use_vad"].set(bool(audio.get("use_vad", False)))
        self.vars["vad_threshold"].set(float(audio.get("vad_threshold", 0.5)))
        self.vars["mute_while_recording"].set(bool(audio.get("mute_while_recording", False)))

        # Overlay
        self.vars["overlay_enabled"].set(bool(overlay.get("enabled", True)))
        self.vars["overlay_position"].set(overlay.get("position", "bottom"))
        self.vars["overlay_opacity"].set(float(overlay.get("opacity", 0.85)))

        # Post-processing
        self.vars["pp_enabled"].set(bool(pp.get("enabled", False)))
        self.vars["pp_api_key"].set(pp.get("openrouter_api_key", ""))
        self.vars["pp_model"].set(pp.get("model", ""))
        self.user_models = list(pp.get("custom_models", []))
        self.model_status.set("Model list: default")
        self._set_model_options(self.user_models + self.default_models)

        self._refresh_devices()
        self._refresh_history()

    def _refresh_devices(self):
        devices: List[str] = ["Default"]
        if sd:
            try:
                devs = sd.query_devices()
                devices += [f"{i}: {d['name']}" for i, d in enumerate(devs) if d.get("max_input_channels", 0) > 0]
            except Exception:
                pass
        self.device_box.configure(values=devices)
        current = self.vars["device_id"].get()
        if current and current in devices:
            self.device_box.set(current)
        else:
            self.device_box.set("Default")

    def _set_model_options(self, options: List[str], status: Optional[str] = None):
        opts = [o for o in options if o]
        if not opts:
            opts = list(self.default_models)
        seen: set[str] = set()
        deduped: List[str] = []
        for o in opts:
            if o in seen:
                continue
            seen.add(o)
            deduped.append(o)
        combined = self.default_models + [m for m in self.user_models if m not in self.default_models]
        self.model_all = combined or list(self.default_models)
        self._filter_models(self.vars["model_search"].get(), status_override=status)
        self._render_model_list()

    def _filter_models(self, query: str, status_override: Optional[str] = None):
        q = (query or "").strip().lower()
        all_models = self.model_all or list(self.default_models)
        filtered = [m for m in all_models if q in m.lower()] if q else list(all_models)
        filtered = filtered[:MAX_MODELS_SHOWN]
        self.model_options = filtered or list(self.default_models)
        try:
            self.model_box.configure(values=self.model_options)
        except Exception:
            pass
        current = self.vars["pp_model"].get()
        if current and current in self.model_options:
            try:
                self.model_box.set(current)
            except Exception:
                pass
        elif self.model_options:
            self.vars["pp_model"].set(self.model_options[0])
            try:
                self.model_box.set(self.model_options[0])
            except Exception:
                pass
        total = len(all_models)
        shown = len(self.model_options)
        summary = status_override or f"Modelos cargados: {total}, mostrando {shown}"
        if q:
            summary += f" (filtro: {q})"
        self.model_status.set(summary)
        self._render_model_list()

    def _refresh_models_async(self):
        # Fixed curated list, no API fetch
        status = f"Modelos cargados: {len(self.default_models)} (lista limitada)"
        self._set_model_options(list(self.default_models), status=status)

    def _test_llm_connection(self):
        key = (self.vars.get("pp_api_key").get() or "").strip()
        model = (self.vars.get("pp_model").get() or "").strip()
        if not key:
            messagebox.showwarning("Missing API key", "Agrega tu OpenRouter API key antes de probar.")
            return
        if not model:
            messagebox.showwarning("Missing model", "Selecciona un modelo antes de probar.")
            return
        if requests is None:
            messagebox.showerror("requests no disponible", "Instala 'requests' para probar la conexion.")
            return

        self._run_llm_test(model_to_test=model, on_success=None, show_snippet=True)

    def _run_llm_test(self, model_to_test: str, on_success=None, show_snippet: bool = False):
        key = (self.vars.get("pp_api_key").get() or "").strip()
        if not key:
            messagebox.showwarning("Missing API key", "Agrega tu OpenRouter API key antes de probar.")
            return
        if requests is None:
            messagebox.showerror("requests no disponible", "Instala 'requests' para probar la conexion.")
            return

        self.test_status.set("Testing...")

        def _worker():
            url = "https://openrouter.ai/api/v1/chat/completions"
            headers = {
                "Authorization": f"Bearer {key}",
                "HTTP-Referer": "https://github.com/whisper-cheap/whisper-cheap",
                "X-Title": "Whisper Cheap",
                "Content-Type": "application/json",
            }
            payload = {
                "model": model_to_test,
                "messages": [
                    {"role": "system", "content": LLM_SYSTEM_PROMPT},
                    {"role": "user", "content": "Transcript:\nHello, this is a connectivity test."},
                ],
            }
            try:
                resp = requests.post(url, headers=headers, json=payload, timeout=15)
                if resp.status_code != 200:
                    msg = f"HTTP {resp.status_code}: {resp.text[:200]}"
                    raise RuntimeError(msg)
                data = resp.json()
                choices = data.get("choices") if isinstance(data, dict) else None
                text = ""
                if choices and isinstance(choices, list) and choices[0].get("message"):
                    text = choices[0]["message"].get("content") or ""
                status = f"OK ({len(text)} chars)" if text else "Respuesta vacia"
                sample = (text[:120] + "...") if text and len(text) > 120 else text
                success = bool(text)
            except Exception as exc:
                status = f"Error: {exc}"
                sample = ""
                success = False

            def _apply():
                self.test_status.set(status)
                if success and on_success:
                    on_success()
                if show_snippet and sample:
                    messagebox.showinfo("Test exitoso", f"Snippet del LLM:\n{sample}")
                elif status.startswith("Error"):
                    messagebox.showerror("Test fallido", status)

            try:
                self.root.after(0, _apply)
            except Exception:
                pass

        threading.Thread(target=_worker, daemon=True).start()

    def _add_model(self):
        model_id = (self.vars.get("add_model").get() or "").strip()
        if not model_id:
            messagebox.showwarning("Modelo vacio", "Introduce el ID del modelo (por ejemplo vendor/model).")
            return
        if model_id in self.default_models or model_id in self.user_models:
            messagebox.showinfo("Modelo existente", "Ese modelo ya esta en la lista.")
            return

        def _on_success():
            self.user_models.append(model_id)
            self.vars["pp_model"].set(model_id)
            self._set_model_options(self.user_models + self.default_models, status="Modelo agregado y probado.")
            self._auto_save()
            self.vars["add_model"].set("")

        self._run_llm_test(model_to_test=model_id, on_success=_on_success, show_snippet=True)

    def _remove_model(self):
        current = (self.vars.get("pp_model").get() or "").strip()
        if not current:
            return
        if current in self.user_models:
            self.user_models = [m for m in self.user_models if m != current]
            self._set_model_options(self.user_models + self.default_models, status="Modelo eliminado.")
            # if current was selected, switch to first available
            combined = self.default_models + [m for m in self.user_models if m not in self.default_models]
            if combined:
                self.vars["pp_model"].set(combined[0])
                self.model_box.set(combined[0])
            self._auto_save()
        else:
            messagebox.showinfo("No se puede eliminar", "Solo puedes eliminar modelos agregados por el usuario. Los modelos base se pueden restaurar con Reset defaults.")

    def _reset_models(self):
        self.user_models = []
        self._set_model_options(self.default_models, status="Lista restaurada a valores por defecto.")
        if self.default_models:
            self.vars["pp_model"].set(self.default_models[0])
        self._auto_save()
        self._render_model_list()

    def _render_model_list(self):
        # Clear existing
        for widget in self.model_list_frame.winfo_children():
            widget.destroy()
        active = self.vars["pp_model"].get().strip()
        for model_id in self.model_options:
            row = ctk.CTkFrame(self.model_list_frame, fg_color=COLORS["card_bg"], corner_radius=8)
            row.pack(fill="x", pady=4, padx=4)
            label = ctk.CTkLabel(row, text=model_id, font=("JetBrains Mono", 12), text_color=COLORS["text"] if model_id == active else COLORS["text_dim"])
            label.pack(side="left", padx=8, pady=6)
            select_btn = ctk.CTkButton(row, text="Select" if model_id != active else "Selected", width=80, height=28, corner_radius=8, font=("JetBrains Mono", 11, "bold"), fg_color=COLORS["accent"] if model_id != active else COLORS["panel"], hover_color=COLORS["accent_hover"], text_color="#000000", command=lambda m=model_id: self._select_model(m))
            select_btn.pack(side="right", padx=6, pady=6)
            if model_id in self.user_models:
                del_btn = ctk.CTkButton(row, text="Delete", width=70, height=28, corner_radius=8, font=("JetBrains Mono", 11, "bold"), fg_color=COLORS["panel"], hover_color=COLORS["panel_hover"], command=lambda m=model_id: self._delete_model(m))
                del_btn.pack(side="right", padx=6, pady=6)

    def _select_model(self, model_id: str):
        self.vars["pp_model"].set(model_id)
        self._auto_save()
        self._render_model_list()

    def _delete_model(self, model_id: str):
        if model_id in self.user_models:
            self.user_models = [m for m in self.user_models if m != model_id]
            # If the active model is removed, fallback
            if self.vars["pp_model"].get() == model_id:
                fallback = self.default_models[0] if self.default_models else (self.user_models[0] if self.user_models else "")
                self.vars["pp_model"].set(fallback)
            self._set_model_options(self.user_models + self.default_models, status="Modelo eliminado.")
            self._auto_save()

    def _show_section(self, name: str):
        for sec, frame in self.section_frames.items():
            frame.pack_forget()
        frame = self.section_frames.get(name)
        if frame:
            frame.pack(fill="both", expand=True)

        # Update nav button colors with high contrast
        for sec, btn in self.nav_buttons.items():
            if sec == name:
                btn.configure(fg_color=COLORS["accent"], text_color="#000000", font=("JetBrains Mono", 14, "bold"))
            else:
                btn.configure(fg_color="transparent", text_color=COLORS["text_dim"], font=("JetBrains Mono", 14, "bold"))

    def _save(self):
        """Legacy save method - now just closes window since we have auto-save"""
        self.root.destroy()

    def show(self):
        self.root.mainloop()

    # ---------- actions ----------
    def _refresh_history(self):
        # Clear existing cards
        for widget in self.history_cards_frame.winfo_children():
            widget.destroy()

        if not self.history_manager:
            empty_label = ctk.CTkLabel(
                self.history_cards_frame,
                text="(Historial no disponible)",
                font=("JetBrains Mono", 11),
                text_color=COLORS["text_dim"]
            )
            empty_label.pack(pady=40)
            return

        try:
            entries = self.history_manager.get_all(limit=20)
            if not entries:
                empty_label = ctk.CTkLabel(
                    self.history_cards_frame,
                    text="No hay transcripciones todavia.\nGraba algo con el hotkey para comenzar.",
                    font=("JetBrains Mono", 11),
                    text_color=COLORS["text_dim"],
                    justify="center"
                )
                empty_label.pack(pady=40)
            else:
                for entry in entries:
                    self._create_history_card(entry)
        except Exception as e:
            error_label = ctk.CTkLabel(
                self.history_cards_frame,
                text=f"Error al cargar historial:\n{e}",
                font=("JetBrains Mono", 11),
                text_color=COLORS["accent"],
                justify="center"
            )
            error_label.pack(pady=40)

    def _create_history_card(self, entry: Dict[str, Any]):
        """Create a single history card matching Handy's style"""
        card = ctk.CTkFrame(self.history_cards_frame, fg_color=COLORS["card_bg"], corner_radius=12)
        card.pack(fill="x", pady=(0, 12))

        content = ctk.CTkFrame(card, fg_color="transparent")
        content.pack(fill="both", expand=True, padx=20, pady=16)

        # Header: timestamp + actions
        header = ctk.CTkFrame(content, fg_color="transparent")
        header.pack(fill="x", pady=(0, 12))

        # Timestamp
        ts = entry.get("timestamp", 0)
        dt_str = datetime.fromtimestamp(ts).strftime("%B %d, %Y at %I:%M %p") if ts else "Unknown date"
        timestamp = ctk.CTkLabel(
            header,
            text=dt_str,
            font=("JetBrains Mono", 12, "bold"),
            text_color=COLORS["text"]
        )
        timestamp.pack(side="left")

        # Action buttons
        actions = ctk.CTkFrame(header, fg_color="transparent")
        actions.pack(side="right")

        # Copy button
        copy_btn = ctk.CTkButton(
            actions,
            text="COPY",
            width=36,
            height=32,
            corner_radius=8,
            fg_color="transparent",
            hover_color=COLORS["panel_hover"],
            font=("JetBrains Mono", 16),
            command=lambda e=entry: self._copy_transcription(e)
        )
        copy_btn.pack(side="left", padx=4)

        # Delete button
        delete_btn = ctk.CTkButton(
            actions,
            text="DEL",
            width=36,
            height=32,
            corner_radius=8,
            fg_color="transparent",
            hover_color=COLORS["accent_dim"],
            font=("JetBrains Mono", 16),
            command=lambda e=entry: self._delete_entry(e)
        )
        delete_btn.pack(side="left", padx=4)

        # Transcription text (italic style)
        text = entry.get("transcription_text", "")
        if text:
            text_label = ctk.CTkLabel(
                content,
                text=text,
                font=("JetBrains Mono", 13, "italic"),
                text_color=COLORS["text_dim"],
                justify="left",
                anchor="w",
                wraplength=800
            )
            text_label.pack(fill="x", pady=(0, 14))

        # Audio player (if audio file exists)
        audio_path = entry.get("audio_path", "")
        if audio_path and Path(audio_path).exists():
            player = ctk.CTkFrame(content, fg_color=COLORS["panel"], corner_radius=8, height=48)
            player.pack(fill="x")
            player.pack_propagate(False)

            player_content = ctk.CTkFrame(player, fg_color="transparent")
            player_content.pack(fill="both", expand=True, padx=12, pady=8)

            # Play button
            play_btn = ctk.CTkButton(
                player_content,
            text="PLAY",
                width=32,
                height=32,
                corner_radius=16,
                fg_color=COLORS["accent"],
                hover_color=COLORS["accent_hover"],
                font=("JetBrains Mono", 12),
                command=lambda p=audio_path: self._play_audio(p)
            )
            play_btn.pack(side="left", padx=(0, 12))

            # Timeline
            timeline_frame = ctk.CTkFrame(player_content, fg_color="transparent")
            timeline_frame.pack(side="left", fill="x", expand=True)

            # Progress bar
            progress = ctk.CTkProgressBar(
                timeline_frame,
                height=4,
                fg_color=COLORS["bg"],
                progress_color=COLORS["accent"]
            )
            progress.pack(fill="x", pady=(8, 4))
            progress.set(0)

            # Duration label
            try:
                import wave
                with wave.open(audio_path, 'r') as wf:
                    frames = wf.getnframes()
                    rate = wf.getframerate()
                    duration = frames / float(rate)
                    duration_str = f"0:00 / {int(duration//60)}:{int(duration%60):02d}"
            except Exception:
                duration_str = "0:00 / 0:00"

            duration_label = ctk.CTkLabel(
                timeline_frame,
                text=duration_str,
                font=("JetBrains Mono", 9),
                text_color=COLORS["text_dim"]
            )
            duration_label.pack(anchor="w")

    def _copy_transcription(self, entry: Dict[str, Any]):
        """Copy transcription text to clipboard"""
        text = entry.get("transcription_text", "")
        if text:
            try:
                import pyperclip
                pyperclip.copy(text)
            except Exception:
                pass

    def _delete_entry(self, entry: Dict[str, Any]):
        """Delete history entry"""
        # TODO: Implement delete with confirmation
        pass

    def _play_audio(self, audio_path: str):
        """Play audio file"""
        # TODO: Implement audio playback
        try:
            if sys.platform == "win32":
                os.startfile(audio_path)
        except Exception:
            pass

    def _open_recordings_folder(self):
        try:
            recordings_path = self.config_path.parent / ".data" / "recordings"
            if not recordings_path.exists():
                paths_config = self.data.get("paths", {})
                app_data = paths_config.get("app_data", ".data")
                app_data = os.path.expandvars(app_data)
                recordings_path = Path(app_data) / "recordings"

            if recordings_path.exists():
                if sys.platform == "win32":
                    os.startfile(str(recordings_path))
                elif sys.platform == "darwin":
                    subprocess.run(["open", str(recordings_path)])
                else:
                    subprocess.run(["xdg-open", str(recordings_path)])
            else:
                messagebox.showwarning("Carpeta no encontrada", f"La carpeta de grabaciones no existe:\n{recordings_path}")
        except Exception as e:
            messagebox.showerror("Error", f"No se pudo abrir la carpeta:\n{e}")

    def _open_app_data_folder(self):
        try:
            paths_config = self.data.get("paths", {})
            app_data = paths_config.get("app_data", ".data")
            app_data = os.path.expandvars(app_data)
            app_data_path = self.config_path.parent / app_data if not Path(app_data).is_absolute() else Path(app_data)

            if app_data_path.exists():
                if sys.platform == "win32":
                    os.startfile(str(app_data_path))
                elif sys.platform == "darwin":
                    subprocess.run(["open", str(app_data_path)])
                else:
                    subprocess.run(["xdg-open", str(app_data_path)])
            else:
                messagebox.showwarning("Carpeta no encontrada", f"La carpeta de datos no existe:\n{app_data_path}")
        except Exception as e:
            messagebox.showerror("Error", f"No se pudo abrir la carpeta:\n{e}")


def open_modern_settings(config_path: Path, history_manager=None):
    def _run():
        win = ModernSettingsWindow(config_path, history_manager=history_manager)
        win.show()

    threading.Thread(target=_run, daemon=True).start()
